<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- CLEAN CSP ‚Äî no comments, no frame‚Äëancestors when using <meta>, add style‚Äësrc -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self';
                  base-uri 'self';
                  object-src 'none';
                  script-src 'self' 'unsafe-inline' blob:
                              https://cdnjs.cloudflare.com
                              https://cdn.jsdelivr.net
                              https://accounts.google.com
                              https://apis.google.com;
                  worker-src 'self' blob:;
                  style-src 'self' 'unsafe-inline';
                  img-src 'self' data:;
                  font-src 'self' https://fonts.gstatic.com;
                  connect-src 'self' https://accounts.google.com https://www.googleapis.com ws:;
                  frame-src https://accounts.google.com https://picker.googleapis.com https://docs.google.com 
                  ">


      <link rel="icon" href="./favicon/favicon.ico">
      <title>lab12</title> <!-- Updated title -->
      <script>window.currentUser = null;</script>
      <script>window.currentUserFullName = null;</script>      

      <!-- ‚Äì‚Äì‚Äì Markdown renderer ‚Äì‚Äì‚Äì -->
      <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" referrerpolicy="no-referrer"></script>
      <!-- HTML sanitizer -->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.7/purify.min.js"></script>
    <!-- ‚Äì‚Äì‚Äì‚Äì‚Äì Google Identity Services ‚Äì‚Äì‚Äì‚Äì‚Äì                     -->
    <script>
      const GOOGLE_CLIENT_ID = "1024744015168-0nni6g7fg6q425lueq3s5ii98s85slek.apps.googleusercontent.com";
      const GOOGLE_DRIVE_SCOPES = "https://www.googleapis.com/auth/drive.file";

      // 2) A robust updater that looks up DOM/globals at call time
      window.updateGDriveButtonState = function () {
        const btn = document.getElementById("save-gdrive-btn");
        if (!btn) return;
        const ready = !!(window.googleTokenClient && window.pickerApiLoaded);
        const notesExist = !!(window.notesMD && window.notesMD.trim());
        const enabled = ready && !!window.currentUser && notesExist;
        btn.disabled = !enabled;
        btn.classList.toggle("hidden", !enabled);
      };

      function onGoogleGsiLoad() {
        window.googleTokenClient = google.accounts.oauth2.initTokenClient({
          client_id: GOOGLE_CLIENT_ID,
          scope: GOOGLE_DRIVE_SCOPES,
          // wrap so it always calls the *current* global handler
          callback: resp => window.handleGoogleTokenResponse(resp)
        });
        // console.log("onGoogleGsiLoad fired. Client:", window.googleTokenClient);
        window.gisInited = true;
        window.updateGDriveButtonState();
      }

      function onGoogleApiLoad() {
        gapi.load("picker", () => {
          // console.log("gapi.load('picker') callback fired."); // Add this log
          window.pickerApiLoaded = true; // Make sure this line exists and is correct
          // console.log("onGoogleApiLoad -> picker loaded. Flag:", window.pickerApiLoaded); // Log *after* setting
          window.updateGDriveButtonState(); // Update state *after* flag is set
        });
      }
    </script>


    <script id="gsi" src="https://accounts.google.com/gsi/client" defer onload="onGoogleGsiLoad()"></script>

    <!-- ‚Äì‚Äì‚Äì‚Äì‚Äì Google JS API loader (for Picker) ‚Äì‚Äì‚Äì‚Äì‚Äì            -->
    <script src="https://apis.google.com/js/api.js?onload=onGoogleApiLoad"  defer></script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- Navigation Bar -->
  <nav class="navbar">
    <div class="navbar-brand">üéôÔ∏è Lab12</div>
    <div class="navbar-links">
      <span id="user-info" class="user-info hidden"></span> <!-- Placeholder for user info -->
      <button id="auth-button" class="nav-button">Login</button> <!-- Placeholder for Login/Logout -->
      <a href="#" id="feedback-link" class="nav-link">Feedback</a> <!-- Placeholder for Feedback -->
    </div>
  </nav>

  <div class="container">
    <!-- Status Indicator (Moved below controls for better visibility) -->
    <div id="status-indicator" class="status-bar">
      <span class="status-dot" id="status-dot"></span>
      <span class="status" id="status-text">Ready</span>
    </div>

    <!-- Authentication Modal -->
    <div id="login-modal" class="login-page" style="display: none;"> <!-- Initially hidden -->
      <div class="login-container">
        <span class="close-button" id="close-login-modal">&times;</span> <!-- Close button -->
        <h2 id="login-title">Login</h2>
        <form id="login-form">
          <div class="input-group" id="fullname-group" style="display:none">
            <input id="login-fullname" name="full_name"
            type="text" placeholder="Full Name" autocomplete="name">
          </div>
          <div class="input-group">
            <input id="login-email" type="email" placeholder="Email" autocomplete="email" required>
          </div>
          <div class="input-group">
            <input id="login-password" type="password" placeholder="Password" autocomplete="current-password"required>
          </div>
          <div class="input-group" id="confirm-group" style="display: none;">
            <input id="login-confirm" name="password_confirm" type="password" placeholder="Re-enter password" autocomplete="new-password">
          </div>
          <label style="font-size:14px; margin-bottom:15px; display:flex; align-items:center;">
            <input id="toggle-show-pwd" type="checkbox" style="margin-right:6px;">
            Show password
          </label>
          <p id="login-error" style="color:red;   height:1.2em;"></p>
          <p id="login-success" style="color:green; height:1.2em;"></p>
          <button type="submit" class="login-btn" id="login-submit">Log in</button>
          <p id="login-toggle" class="signup-link">Create an account</p>
        </form>
      </div>
    </div>

    <div class="controls">
      <button id="btn">üé§ Start Recording</button>
      <button id="pause-btn" class="hidden">‚è∏Ô∏è Pause</button>
      <button id="sum" disabled>üìù Generate Notes</button>
      <!-- <button id="dl" class="hidden">‚¨áÔ∏è Download PDF</button> -->
      <button id="save-gdrive-btn" class="hidden">üíæ Save to Google Drive</button>
      <button id="clear-all-btn" class="secondary hidden">üóëÔ∏è Clear All</button> <!-- Initially hidden -->
      <button id="toggle-custom-instructions" class="secondary">‚öôÔ∏è Custom Note Instructions</button>
    </div>

    <div id="custom-instructions-section" class="hidden">
      <h4>Custom Note Instructions</h4>
      <textarea id="custom-instructions"
        placeholder="Enter simple instructions for the AI note-taker here. Example: Focus on action items and decisions made. OR Provide a very brief summary."></textarea>
    </div>

    <div class="section">
      <div class="section-title">
        <span>üîä Live Transcript</span>
      </div>
      <div id="log" class="content-box"></div>
    </div>

    <div class="section">
      <div class="section-title">
        <span>üìú Full Transcript</span>
        <span class="edit-cue">(Click to edit)</span>
      </div>
      <div id="full" class="content-box" contenteditable="true"></div>
    </div>

    <div id="notes-section" class="section hidden">
      <div class="section-title">
        <span>üìã Generated Notes</span>
        <div class="note-actions">
          <!-- <button id="toggle-preview" class="secondary hidden">Raw</button> -->
          <span id="quota-info" class="quota-info hidden"></span>
          <button id="copy-notes" class="secondary hidden">üìã Copy</button>
        </div>
      </div>
      <div id="notes" class="content-box"></div>
    </div>

    <!-- Feedback Form Modal (Initially hidden) -->
    <div id="feedback-modal" class="feedback-modal hidden">
      <div class="feedback-container">
        <span class="close-button" id="close-feedback-modal">&times;</span> <!-- Close button -->
        <h2>Feedback</h2>
        <form id="feedback-form">
          <textarea id="feedback-text" placeholder="Enter your feedback here..." required></textarea>
          <div class="feedback-buttons">
            <button type="submit" id="submit-feedback">Submit</button>
            <button type="button" id="cancel-feedback">Cancel</button>
          </div>
        </form>
      </div>
    </div>

  </div> <!-- End of .container -->

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const $ = selector => {
        if (selector.startsWith("#")) selector = selector.slice(1);
        return document.getElementById(selector);
      };

      window.notesMD = "";

      window.handleGoogleTokenResponse = (tokenResponse) => {
        window.googleAccessToken = tokenResponse.access_token;
        console.log("Google access token:", window.googleAccessToken);
        window.updateGDriveButtonState();
      };

      let isLoginMode = true; // Renamed from isLogin to avoid conflict
      const modal = $("login-modal");
      const title = $("login-title");
      const form = $("login-form");
      const fullnameInput = $("login-fullname");
      const fullnameGrp = $("fullname-group");
      const email = $("login-email");
      const pwd = $("login-password");
      const confirmInput = $("login-confirm");
      const confGrp = $("confirm-group");
      const toggle = $("login-toggle");
      const showPwd = $("toggle-show-pwd");
      const submitB = $("login-submit");
      const errMsg = $("login-error");
      const okMsg = $("login-success");

      // Navbar elements
      const authButton = $("auth-button");
      const userInfoSpan = $("user-info");
      const feedbackLink = $("feedback-link");

      // Feedback Modal elements
      const feedbackModal = $("feedback-modal");
      const feedbackForm = $("feedback-form");
      const cancelFeedbackBtn = $("cancel-feedback");
      const feedbackText = $("feedback-text");
      const submitFeedbackBtn = $("submit-feedback"); // Get submit button

      const wsProtocol = location.protocol === "https:" ? "wss" : "ws";
      const WS_BASE_URL = `${wsProtocol}://${location.host}/ws/stt`;
      const LOCAL_STORAGE_KEY = "liveNoteSession";
      const GOOGLE_APP_ID = GOOGLE_CLIENT_ID.split("-")[0];

      let ws, audioCtx, processor, stream, running = false, paused = false;
      let saveTimeout;
      let googleAccessToken = null;
      let pickerOpenRequested = false;

      const log = $("log");
      const full = $("full");
      const notes = $("notes");
      const sumBtn = $("sum");
      const saveGDriveBtn = $("save-gdrive-btn");
      const clearAllBtn = $("clear-all-btn");
      const notesSection = $("notes-section");
      const statusDot = $("status-dot");
      const statusText = $("status-text");
      const startBtn = $("btn");
      const pauseBtn = $("pause-btn");
      const toggleCustomInstructionsBtn = $("toggle-custom-instructions");
      const customInstructionsSection = $("custom-instructions-section");
      const customInstructionsTextarea = $("custom-instructions");
      const copyBtn = $("copy-notes");

      let currentUser = null;
      let lastQuota = null;

      async function bootstrapAuth() {
        const res = await fetch("/me", { credentials: "include" });
        if (res.ok) {
          const { username, full_name } = await res.json();
          currentUser = username;
          window.currentUserFullName = full_name;      // ‚Üê store full name
          updateAuthUI();
        } else {
          currentUser = null;
          window.currentUserFullName = null;
          updateAuthUI();
        }
      }
      if (currentUser && !data.email_verified) {
        document.body.insertAdjacentHTML("afterbegin",
          `<div class="banner">Verify your e‚Äëmail
        <button id="resend">Resend code</button></div>`);
        $("#resend").onclick = () =>
          fetch("/email/verify/send", {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: currentUser })
          });
      }
      window.addEventListener("DOMContentLoaded", bootstrapAuth);

      function openModal() {
        modal.style.display = "flex";
        errMsg.textContent = okMsg.textContent = "";
      }

      function closeModal() {
        modal.style.display = "none";
      }

      function switchAuthMode() {
        isLoginMode = !isLoginMode;
        title.textContent = isLoginMode ? "Login" : "Sign up";
        submitB.textContent = isLoginMode ? "Log in" : "Sign up";
        toggle.textContent = isLoginMode ? "Create an account" : "Already registered? Log in";

        confGrp.style.display = isLoginMode ? "none" : "block";
        fullnameGrp.style.display = isLoginMode ? "none" : "block";
        confirmInput.required = !isLoginMode;
        fullnameInput.required = !isLoginMode;

        pwd.placeholder = isLoginMode ? "Password" : "Enter a password";
        confirmInput.value = fullnameInput.value = "";
        errMsg.textContent = okMsg.textContent = "";
      }

      toggle.addEventListener("click", switchAuthMode);
      showPwd.addEventListener("change", () => {
        const t = showPwd.checked ? "text" : "password";
        pwd.type = confirmInput.type = t;
      });

      form.addEventListener("submit", async e => {
        e.preventDefault();
        errMsg.textContent = okMsg.textContent = "";

        if (!isLoginMode && pwd.value !== confirmInput.value) {
          errMsg.textContent = "Passwords do not match";
          return;
        }

        const endpoint = isLoginMode ? "/token" : "/register";
        const fd = new FormData();
        fd.append("username", email.value);
        fd.append("password", pwd.value);
        if (!isLoginMode) {
          fd.append("full_name", fullnameInput.value.trim());
        }
        try {
          const res = await fetch(endpoint, {
            method: "POST",
            body: fd,
            credentials: "include"
          });

          if (!res.ok) {
            const { detail = "Auth failed" } = await res.json();
            throw new Error(detail);
          }

          if (isLoginMode) {
            await bootstrapAuth();           // loads username via /me
            okMsg.textContent = "Success! Loading‚Ä¶";
            setTimeout(() => { closeModal(); loadSession(); }, 500);
          } else {
            okMsg.textContent = "Enter the 6-digit code we e-mailed you.";
            title.textContent = "Verify e-mail";
            isLoginMode = true;               // reuse form as ‚Äúverify‚Äù
            email.readOnly = true;            // stop users changing it

            fullnameGrp.style.display = "none";        // Hide Full Name group
            confGrp.style.display = "none";          // Hide Confirm Password group
            showPwd.parentElement.style.display = "none"; // Hide "Show password" label/checkbox

            pwd.type = "text";
            pwd.placeholder = "6-digit code";
            pwd.style.display = "block";
            pwd.autocomplete = "one-time-code"
            pwd.value = "";
            pwd.focus(); // Focus the PIN input

            toggle.style.display = "none";
            submitB.textContent = "Verify";

            // change submit handler (quick hack)
            form.onsubmit = async ev => {
              ev.preventDefault();
              okMsg.textContent = ""; // Clear previous success message
              errMsg.textContent = ""; // Clear previous error message
              const pin = pwd.value.trim();            // we‚Äôll reuse hidden pwd input
              if (!pin || !/^\d{6}$/.test(pin)) { // Basic validation for 6 digits
                errMsg.textContent = "Please enter the 6-digit code.";
                return;
              }
              try {
                const verifyRes = await fetch("/email/verify/check", { // Ensure correct endpoint
                  method: "POST",
                  // credentials: "include", // Include cookies if needed by this endpoint
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ email: email.value, pin: pin }) // Send email and PIN
                });
                if (verifyRes.ok) {
                  okMsg.textContent = "‚úÖ Verified - you can now log in";
                  // Optionally log the user in directly or reload
                  setTimeout(() => location.reload(), 1500);
                } else {
                  const errData = await verifyRes.json().catch(() => ({}));
                  errMsg.textContent = errData.detail || "Wrong / expired code.";
                }
              } catch (verifyErr) {
                console.error("Error during verification check:", verifyErr);
                errMsg.textContent = "Verification request failed.";
              }
            };
          }
        } catch (err) {
          errMsg.textContent = err.message;
        }
      });

      async function fetchQuota() {
        const res = await fetch("/me/quota", { credentials: "include" });
        if (res.ok) {
          lastQuota = await res.json();
          paintQuota();
        }
      }
      function paintQuota() {
          const el = $("quota-info");
          if (currentUser && lastQuota) {
            el.textContent = `Credits: ${lastQuota.remaining}‚ÄØ/‚ÄØ${lastQuota.plan.quota}`;
            el.classList.remove("hidden");
          } else {
            el.classList.add("hidden");
          }
        }

      bootstrapAuth().then(fetchQuota);

      // --- Add Event Listeners for Modal Close Buttons ---
      const closeLoginBtn = $("close-login-modal");
      const closeFeedbackBtn = $("close-feedback-modal");

      if (closeLoginBtn) {
        closeLoginBtn.onclick = closeModal;
      }
      if (closeFeedbackBtn) {
        closeFeedbackBtn.onclick = closeFeedbackModal;
      }

      // --- Function to update Clear All button visibility --- START
      function updateClearAllButtonVisibility() {
        const hasLogContent = log.textContent.trim().length > 0;
        const hasFullContent = full.textContent.trim().length > 0;
        const hasNotesContent = notes.innerHTML.trim().length > 0;
        const hasContent = hasLogContent || hasFullContent || hasNotesContent;
        clearAllBtn.classList.toggle("hidden", !hasContent);
      }
      // --- Function to update Clear All button visibility --- END

      function updateAuthUI() {
        window.currentUser = currentUser; 
          if (currentUser) {
              fetchQuota(); 
              const name = window.currentUserFullName || currentUser;
              userInfoSpan.textContent = `Welcome back, ${name}!`;
              userInfoSpan.classList.remove("hidden");
              authButton.textContent = "Logout";
              authButton.onclick = logout;
              feedbackLink.classList.remove("hidden");
            } else {
              userInfoSpan.textContent = "";
              userInfoSpan.classList.add("hidden");
              authButton.textContent = "Login";
              authButton.onclick = openModal;
              feedbackLink.classList.add("hidden");
            }

          sumBtn.disabled = !(full.textContent.trim() && currentUser);
          updateGDriveButtonState();
          updateClearAllButtonVisibility();
        }

        async function logout() {
          await fetch("/logout", {
            method: "POST",
            credentials: "include"
          });
          currentUser = null;
          updateAuthUI();
        }
        authButton.onclick = logout; 

      // Check token status on initial load
      updateAuthUI();
      if (!currentUser) {
        openModal(); // Open login if not logged in
      }

      // --- Feedback Modal --- 
      function openFeedbackModal() {
        feedbackModal.classList.remove("hidden");
      }

      function closeFeedbackModal() {
        feedbackModal.classList.add("hidden");
        feedbackText.value = ""; // Clear text on close
      }

      feedbackLink.onclick = (e) => {
        e.preventDefault(); // Prevent default link behavior
        openFeedbackModal();
      };
      cancelFeedbackBtn.onclick = closeFeedbackModal;

      feedbackForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const feedback = feedbackText.value.trim();
        if (!feedback) {
          alert("Please enter your feedback before submitting.");
          return;
        }
        if (!currentUser) {
          alert("Please log in to submit feedback.");
          openModal();
          return;
        }

        submitFeedbackBtn.disabled = true;
        submitFeedbackBtn.textContent = "Submitting...";

        try {
          const res = await fetchWithAuth("/feedback", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ feedback_text: feedback })
          });

          if (!res.ok) {
            const err = await res.json().catch(() => ({}));
            if (res.status === 402) throw new Error(err.detail); // quota
            throw new Error(err.detail || `HTTP ${res.status}`);
          }

          const result = await res.json();
          console.log("Feedback submission result:", result);
          alert("Thank you for your feedback!");
          closeFeedbackModal();
        } catch (err) {
          console.error("Error submitting feedback:", err);
          alert(`Failed to submit feedback: ${err.message}`);
        } finally {
          submitFeedbackBtn.disabled = false;
          submitFeedbackBtn.textContent = "Submit";
        }
      });

      // --- Fetch with Auth --- 
      async function fetchWithAuth(url, options = {}) {
        if (!currentUser) {
          console.error("No JWT token found. Please log in.");
          openModal(); // Prompt login
          throw new Error("Authentication required.");
        }

        const response = await fetch(url, { ...options, credentials: "include" });

        if (response.status === 401) {
          // Unauthorized, likely expired token
          console.warn("JWT token expired or invalid. Logging out.");
          logout();
          throw new Error("Session expired. Please log in again.");
        }
        return response;
      }

      // --- Status Update --- 
      function updateStatus(state, message) {
        // console.log(`Updating status: ${state} - ${message}`); // Debug log
        statusText.textContent = message;
        // Reset classes first
        statusDot.className = "status-dot";
        statusText.className = "status";

        switch (state) {
          case "ready":
            statusText.textContent = message;
            break;
          case "connecting":
            statusDot.classList.add("paused"); // Use warning color for connecting
            statusText.classList.add("paused");
            break;
          case "active":
          case "recording": // Treat recording as active
            statusDot.classList.add("active");
            statusText.classList.add("active");
            break;
          case "paused":
            statusDot.classList.add("paused");
            statusText.classList.add("paused");
            break;
          case "summarizing":
            statusDot.classList.add("paused"); // Use warning color for summarizing
            statusText.classList.add("paused");
            break;
          case "error":
            statusDot.classList.add("error");
            statusText.classList.add("error");
            break;
          default:
            console.warn("Unknown status state:", state);
        }
      }

      // --- WebSocket Handling --- 
      function connectWebSocket() {
        if (!currentUser) {
          openModal();
          return;
        }
        const wsUrl = WS_BASE_URL;
        ws = new WebSocket(wsUrl);
        updateStatus("connecting", "Connecting...");

        ws.onopen = () => {
          console.log("WebSocket connected");
          running = true;
          paused = false;
          updateStatus("active", "Recording...");
          startBtn.textContent = "üõë Stop Recording";
          startBtn.classList.add("recording");
          pauseBtn.classList.remove("hidden");
          pauseBtn.textContent = "‚è∏Ô∏è Pause";
          pauseBtn.classList.remove("paused");
          startAudioProcessing();
        };

        let interimNode = null;

        ws.onmessage = event => {
          const data = JSON.parse(event.data);

          if (data.error) {
            console.error("WebSocket error:", data.error);
            updateStatus("error", `Error: ${data.error}`);
            stopRecording();
            return;
          }

          // Final result
          if (data.text !== undefined) {
            // Remove any existing interim line
            if (interimNode) {
              interimNode.remove();
              interimNode = null;
            }
            // Append the final transcript chunk
            appendLog(data.text, /* isFinal= */ true);
            updateFullTranscript(data.text);

            // Interim (partial) result
          } else if (data.partial !== undefined) {
            // If we don't yet have an interim node, create one
            if (!interimNode) {
              interimNode = document.createElement("div");
              interimNode.style.color = "grey";
              log.appendChild(interimNode);
              log.scrollTop = log.scrollHeight;
            }
            // Update its text with the latest partial
            interimNode.textContent = data.partial;
          }
        };

        ws.onerror = error => {
          console.error("WebSocket error:", error);
          updateStatus("error", "Connection error");
          running = false;
        };

        ws.onclose = (event) => {
          console.log("WebSocket closed:", event.code, event.reason);
          running = false;
          paused = false;
          updateStatus("ready", event.reason || "Disconnected");
          startBtn.textContent = "üé§ Start Recording";
          startBtn.classList.remove("recording");
          pauseBtn.classList.add("hidden");
          stopAudioProcessing();
          // Attempt to reconnect if closed unexpectedly?
        };
      }

      // --- Audio Processing --- 
      async function startAudioProcessing() {
        try {
          stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioCtx = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: 16000
          });
          const source = audioCtx.createMediaStreamSource(stream);

          // --- Embed AudioWorklet code --- START
          const workletCode = `
            class AudioProcessor extends AudioWorkletProcessor {
              process(inputs, outputs, parameters) {
                const input = inputs[0];
                if (input.length > 0) {
                  const channelData = input[0]; // Use the first channel
                  const buffer = new Int16Array(channelData.length);
                  for (let i = 0; i < channelData.length; i++) {
                    buffer[i] = Math.max(-1, Math.min(1, channelData[i])) * 32767; // Convert to Int16
                  }
                  this.port.postMessage(buffer, [buffer.buffer]); // Send buffer, transferring ownership
                }
                return true; // Keep processor alive
              }
            }
            registerProcessor('audio-processor', AudioProcessor);
          `;
          const blob = new Blob([workletCode], { type: 'application/javascript' });
          const workletURL = URL.createObjectURL(blob);
          // --- Embed AudioWorklet code --- END

          await audioCtx.audioWorklet.addModule(workletURL); // Use Blob URL
          processor = new AudioWorkletNode(audioCtx, "audio-processor");
          source.connect(processor).connect(audioCtx.destination);

          processor.port.onmessage = (event) => {
            if (ws && ws.readyState === WebSocket.OPEN && !paused) {
              // console.debug("sending audio chunk, bytes:", event.data.byteLength);
              ws.send(event.data); // Send Int16Array audio chunk
            } else {
              // console.warn("not sending chunk‚Äîws.ready?", ws.readyState, "paused?", paused);
            }
          };

        } catch (err) {
          console.error("Error accessing microphone or setting up audio:", err);
          updateStatus("error", "Mic access failed");
          stopRecording();
        }
      }

      function stopAudioProcessing() {
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
          stream = null;
        }
        if (processor) {
          processor.disconnect();
          processor = null;
        }
        if (audioCtx) {
          audioCtx.close();
          audioCtx = null;
        }
      }

      // --- UI Updates --- 
      function appendLog(text, isFinal) {
        const entry = document.createElement("div");
        entry.textContent = text;
        if (isFinal) {
          entry.style.color = "black";
        } else {
          entry.style.color = "grey";
        }
        log.appendChild(entry);
        log.scrollTop = log.scrollHeight;
        updateClearAllButtonVisibility(); // Update button visibility
      }

      function updateFullTranscript(text) {
        full.textContent += text + " ";
        saveSession();
        sumBtn.disabled = !(full.textContent.trim() && currentUser);
        updateClearAllButtonVisibility(); // Update button visibility
      }

      function renderNotes(markdown) {
        window.notesMD = markdown;

        // --- UI toggles ---
        notesSection.classList.remove("hidden");
        // togglePreviewBtn.classList.remove("hidden");
        copyBtn.classList.remove("hidden");
        copyBtn.disabled = !markdown.trim();
        updateGDriveButtonState();

        const html = DOMPurify.sanitize(marked.parse(markdown), { USE_PROFILES: { html: true } });
        notes.innerHTML = html;

        // --- bookkeeping ---
        notes.scrollTop = 0;
        saveSession();
        updateClearAllButtonVisibility();
      }

      // --- Actions --- 
      function startRecording() {
        if (!currentUser) { openModal(); return; }
        if (running) return; // Already running
        clearAllContent(false);
        localStorage.removeItem(LOCAL_STORAGE_KEY);
        connectWebSocket();
      }

      function stopRecording() {
        if (!running) return;
        if (ws) {
          ws.close();
        }
        stopAudioProcessing();
        running = false;
        paused = false;
        startBtn.textContent = "üé§ Start Recording";
        startBtn.classList.remove("recording");
        pauseBtn.classList.add("hidden");
        updateStatus("ready", "Stopped");
        saveSession(); // Final save
      }

      function togglePause() {
        if (!running) return;
        paused = !paused;
        if (paused) {
          pauseBtn.textContent = "‚ñ∂Ô∏è Resume";
          pauseBtn.classList.add("paused");
          updateStatus("paused", "Paused");
          // if (ws && ws.readyState === WebSocket.OPEN) {
          //   ws.send(JSON.stringify({ command: "pause" })); // Inform backend if needed
          // }
        } else {
          pauseBtn.textContent = "‚è∏Ô∏è Pause";
          pauseBtn.classList.remove("paused");
          updateStatus("active", "Recording...");
          // if (ws && ws.readyState === WebSocket.OPEN) {
          //   ws.send(JSON.stringify({ command: "resume" })); // Inform backend if needed
          // }
        }
      }

      async function generateNotes() {
        if (!full.textContent.trim()) return;
        if (!currentUser) { openModal(); return; }

        sumBtn.disabled = true;
        sumBtn.innerHTML = "üìù Generating Notes <span class=\"loading\"></span>";
        updateStatus("summarizing", "Generating notes...");

        try {
          const instructions = customInstructionsTextarea.value.trim() || null;
          const payload = {
            transcript: full.textContent,
            custom_instructions: instructions
          };

          const res = await fetch("/summarize", {
            method: "POST",
            credentials: "include",            // ‚Üê include HttpOnly cookie
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(payload)
          });

          if (!res.ok) {
            const err = await res.json();
            throw new Error(err.detail || `HTTP ${res.status}`);
          }

          const { outline } = await res.json();
          renderNotes(outline);
          await fetchQuota();  
          updateStatus("ready", "Notes generated");

        } catch (err) {
          console.error("Error generating notes:", err);
          updateStatus("error", `Notes Error: ${err.message}`);
        } finally {
          sumBtn.disabled = !(full.textContent.trim());
          sumBtn.innerHTML = "üìù Generate Notes";
        }
      }

      function clearAllContent(confirmNeeded = true) {
        if (confirmNeeded) {
          if (!confirm("Are you sure you want to clear all transcripts and notes?")) {
            return;
          }
        }
        log.innerHTML = "";
        full.textContent = "";
        notes.innerHTML = "";
        window.notesMD = "";
        notesSection.classList.add("hidden");
        sumBtn.disabled = true;
        saveGDriveBtn.classList.add("hidden");
        copyBtn.classList.add("hidden");
        copyBtn.disabled = true;
        updateClearAllButtonVisibility(); // Update button visibility
        updateStatus("ready", "Content cleared");
      }

      function toggleCustomInstructions() {
        customInstructionsSection.classList.toggle("hidden");
      }

      // function toggleNotePreview() {
      //   isPreviewMode = !isPreviewMode;
      //   togglePreviewBtn.textContent = isPreviewMode ? "Raw" : "Preview";
      //   renderNotes(window.notesMD); // Re-render with the new mode
      // }

      // --- Session Saving/Loading --- 
      function saveSession() {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
          const sessionData = {
            logHTML: log.innerHTML,
            fullText: full.textContent,
            notesMarkdown:window.notesMD,
            customInstructions: customInstructionsTextarea.value
          };
          localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(sessionData));
          console.log("Session saved");
        }, 500); // Debounce saving
      }

      function loadSession() {
        const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (savedData) {
          try {
            const sessionData = JSON.parse(savedData);
            log.innerHTML = sessionData.logHTML || "";
            full.textContent = sessionData.fullText || "";
            customInstructionsTextarea.value = sessionData.customInstructions || "";
            if (sessionData.notesMarkdown) {
              renderNotes(sessionData.notesMarkdown);
            }
            console.log("Session loaded");
            updateStatus("ready", "Session loaded");
          } catch (e) {
            console.error("Failed to load session:", e);
            localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear corrupted data
          }
        }
        // console.log("loadSession - Notes MD Length:", window.notesMD?.length);
        // Update UI elements based on loaded content
        sumBtn.disabled = !(full.textContent.trim() && currentUser);
        updateGDriveButtonState();
        updateClearAllButtonVisibility(); // Ensure button visibility is correct on load
      }

      window.handleGoogleTokenResponse = (tokenResponse) => {
        googleAccessToken = tokenResponse.access_token;
        // console.log("Google Access Token obtained.");
        if (pickerOpenRequested) {
          createPicker();
          pickerOpenRequested = false;
        }
      };

      function requestGoogleAccessToken() {
        // console.log("requestGoogleAccessToken called.")
        if (!window.googleTokenClient) {
          console.warn("GSI client not ready yet");
          return;
        }
        if (window.googleTokenClient) {
          // console.log("Calling googleTokenClient.requestAccessToken...");
          // Prompt the user to select a Google Account and ask for consent to share their data
          // when establishing a new session.
          window.googleTokenClient.requestAccessToken({ prompt: "consent" });
        } else {
          console.error("Google Token Client not initialized.");
        }
      }

      function openGooglePicker() {
        // console.log("openGooglePicker called.");
        if (!window.notesMD) {  return; }
        if (!currentUser) { openModal(); return; }

        pickerOpenRequested = true;
        // console.log("openGooglePicker: Checking googleAccessToken:", googleAccessToken);

        if (googleAccessToken) {
          // console.log("openGooglePicker: Access token exists, calling createPicker...");

          createPicker();
        } else {
          // console.log("openGooglePicker: Access token MISSING, calling requestGoogleAccessToken...");

          requestGoogleAccessToken();
        }
      }

      function createPicker() {
        // console.log("createPicker called.");
        if (!googleAccessToken || !window.pickerApiLoaded) {
          console.error("Cannot create picker: Missing token or Picker API not loaded.");
          return;
        }

        const titleMatch = window.notesMD.match(/^#\s*(.+)$/m);
        let baseName = titleMatch ? titleMatch[1].trim() : "lecture-notes";
        const dateMatch = window.notesMD.match(/^\*\*Date & Time:\*\*\s*(.+)$/m);
        if (dateMatch) {
          const safeDate = dateMatch[1].replace(/, /g, "_").replace(/ at /i, "_").replace(/[:\s]+/g, "-").replace(/[^0-9A-Za-z\-_]/g, "");
          baseName = `${baseName}_${safeDate}`;
        }
        baseName = baseName.replace(/[^0-9A-Za-z\-_]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
        const filename = `${baseName}.md`; // Save as Markdown

        const folderView = new google.picker.DocsView(google.picker.ViewId.FOLDERS)
          .setIncludeFolders(true)
          .setSelectFolderEnabled(true);

        // console.log("Building picker with folderView..."); // Log before build

        // Build the picker using the correct view variable:
        const picker = new google.picker.PickerBuilder()
          .setAppId(GOOGLE_APP_ID)
          .setOAuthToken(googleAccessToken)
          .addView(folderView) // <--- CORRECTED LINE
          .setCallback((data) => pickerCallback(data, filename))
          // Optional: Add feature to create new folders within the picker
          .enableFeature(google.picker.Feature.CREATE_NEW_FOLDER)
          .build();

        // console.log("Showing picker..."); // Log before setVisible
        picker.setVisible(true);
        // console.log("picker.setVisible(true) called."); // Log after setVisible
      }
      async function pickerCallback(data, filename) {
        if (data.action === google.picker.Action.PICKED) {
          const folder = data.docs[0];
          const folderId = folder.id;
          const folderName = folder.name; // Good to have for logging/status
          // console.log(`Folder selected: ${folderName} (ID: ${folderId}). Preparing to call backend.`);

          // -------- START: Generate HTML like Copy Button --------
          let generatedHtml;
          try {
            if (!window.notesMD) { // Check if notesMD exists first
              throw new Error("Notes markdown is empty.");
            }
            // Ensure DOMPurify is loaded (it's included in your <head>)
            if (typeof DOMPurify === 'undefined') {
              throw new Error("DOMPurify library is not loaded.");
            }
            const dirtyHtml = marked.parse(window.notesMD);
            generatedHtml = DOMPurify.sanitize(dirtyHtml, { USE_PROFILES: { html: true } });
            // console.log("Generated sanitized HTML for Drive upload.");
          } catch (err) {
            console.error("Error generating/sanitizing HTML for Drive:", err);
            alert(`Failed to prepare notes for saving: ${err.message}`);
            // Optional: Re-enable button if preparation fails
            saveGDriveBtn.disabled = false;
            saveGDriveBtn.innerHTML = "üíæ Save to Google Drive";
            updateStatus("error", `Failed to prepare notes: ${err.message}`);
            return;
          }
          // -------- END: Generate HTML --------


          // Ensure we have everything needed (check generatedHtml instead of notesMD)
          if (!generatedHtml || !folderId || !googleAccessToken || !filename) {
            console.error("Missing data for backend save:", { hasNotes: !!generatedHtml, folderId, hasToken: !!googleAccessToken, filename });
            alert("Cannot save to drive: missing required information.");
            return;
          }

          saveGDriveBtn.disabled = true;
          saveGDriveBtn.innerHTML = "üíæ Saving... <span class=\"loading\"></span>";
          updateStatus("active", `Saving to Drive...`); // Update status

          try {
            // Call YOUR backend endpoint
            const res = await fetchWithAuth("/save-to-drive", { // Use fetchWithAuth
              method: "POST",
              credentials: "include", // Assuming you use cookies now based on backend code
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                // *** CHANGE: Send HTML instead of Markdown ***
                notes_html: generatedHtml,       // <--- SEND THIS
                // notes_content: window.notesMD, // <--- REMOVE THIS
                filename: filename,
                folder_id: folderId,
                google_access_token: googleAccessToken
              })
            });

            const result = await res.json(); // Parse response from *your* backend

            if (!res.ok) {
              // Use error detail from your backend response
              throw new Error(result.detail || `Backend Error ${res.status}`);
            }

            // console.log("Backend save successful:", result);
            // Use the filename returned by the backend
            const savedFileName = result.file_name || filename;
            alert(`‚úÖ Notes saved successfully to Google Drive as '${savedFileName}'!`);
            updateStatus("ready", `Saved as '${savedFileName}'`);

          } catch (err) {
            console.error("Error saving via backend:", err);
            alert(`Failed to save to Google Drive: ${err.message}`);
            updateStatus("error", `Save failed: ${err.message}`);
          } finally {
            saveGDriveBtn.disabled = false; // Re-enable button
            saveGDriveBtn.innerHTML = "üíæ Save to Google Drive";
          }
        } else if (data.action === google.picker.Action.CANCEL) {
          console.log("Google Picker cancelled by user.");
          updateStatus("ready", "Save to Drive cancelled.");
        }
      }
      // --- Event Listeners --- 
      startBtn.onclick = () => { running ? stopRecording() : startRecording(); };
      pauseBtn.onclick = togglePause;
      sumBtn.onclick = generateNotes;
      saveGDriveBtn.onclick = openGooglePicker;
      clearAllBtn.onclick = () => clearAllContent(true); // Pass true for confirmation
      toggleCustomInstructionsBtn.onclick = toggleCustomInstructions;
      // togglePreviewBtn.onclick = toggleNotePreview;

      // Save content periodically and on page unload
      full.addEventListener("input", saveSession);
      customInstructionsTextarea.addEventListener("input", saveSession);
      window.addEventListener("beforeunload", () => {
        clearTimeout(saveTimeout); // Clear any pending save
        saveSession(); // Save immediately before unload
        if (running) {
          // Optional: Warn user if recording is active?
          // return "Recording is in progress. Are you sure you want to leave?";
        }
      });

      copyBtn.onclick = () => {
        if (!window.notesMD) return;              // nothing to copy

        const html = notes.innerHTML;

        /* ‚Äî‚Äî Clipboard API with both flavours ‚Äî‚Äî */
        navigator.clipboard.write([
          new ClipboardItem({
            "text/html": new Blob([html], { type: "text/html" }),
            "text/plain": new Blob([window.notesMD], { type: "text/plain" })
          })
        ]).then(() => {
          copyBtn.textContent = "‚úÖ Copied";            // UX feedback
          setTimeout(() => copyBtn.textContent = "üìã Copy", 1200);
        }).catch(err => {
          console.error("Clipboard write failed:", err);
          alert("Couldn‚Äôt copy ‚Äì see console");
        });
      };

      // Initial load
      loadSession();

    }); 
  </script>

</body>

</html>